id,title,text,path,mark,author_id
1,“What is your current salary?” is a red flag that you don’t want to work here,"Asking for your current salary is not a legitimate question and should be treated as such.
🙄 The dreaded salary question
🤔 Why do some companies still ask this?
🚫 Never tell your current salary
🛑 Consider it a red flag that you are being asked this question
💪 How to push back?
❓ What about people who don't have a choice?
❓ Isn't that too confrontational?
❓ What if I don't have a choice?
❓ Isn't that common sense?
👂 What do recruiters think of this practice?
🙄 The dreaded salary question
Here is the context:
You are on the initial phone screen call with someone from human resources.
Since thirty minutes you are trying to explain succinctly what your life has been about in the last decade to a complete stranger.
Maybe you have been teased with tricky questions on how git works internally, and you have done your best to answer correctly.
You are starting to feel exhausted, but fortunately the call seems to come to an end.
Then suddenly the conversation moves to one last thing:
“And by the way, where are you right now in terms of salary,  and what are your salary expectations if you make this move?”
You may feel the rush to address the second part of the question and skip the first part of the question, but don't. First realize that you are being asked an illegitimate question.
🤔 Why do some companies still ask this?
I spent too much time this year looking for a job. I would be happy to report that tech companies have gotten this, and don't ask for your current salary anymore.
Alas, it's still a current bad practice.
Why? Because it works.
A surprising number of people in this stressful situation will undercut themselves by answering the question.
But it's not a legitimate question.
Imagine you are on the other side of the job interview.
If Alice and Bob have similar skills and can do the same job bringing the same value to the company, why is it relevant how much they were paid before? It is not relevant at all.
What the question does is that it creates a powerful anchoring effect.
A candidate who gives this information away will typically ask for only a bit more than what she is currently getting.
The human resources dude will then have a big internal smile: the candidate's expected salary is below the range that was decided for that position. He will then happily give the candidate 3.000 dollars more than what the candidate asks for.
How generous?
No, it's not generous. It is actually the absolute bottom of the salary range that was decided beforehand for that position.
So there is a huge downside for you to reveal your current salary and no upside whatsoever.
So you have a simple rule to follow:
🚫 Never tell your current salary
Simple, right?
But if you can, I would challenge you to go one step further.
Asking for the current salary is a bad practice that needs to die.
And you  can help it to die faster by pushing back on the question.
🛑 Consider it a red flag that you are being asked this question
Companies try to be consistent in their hiring process.
If you are being asked for your current salary, it's likely that others candidates are being tricked as well.
It's likely that if you were to discuss your salaries with your future colleagues at the water cooler - or at the coffee machine if you are in Europe - you will realize that some colleagues are wildly underpaid.
Does that sound like a good place to work?
Bonus point if the company pretends to care about gender equality in their marketing document about their supposed ""values"".
You know that their actual values is that they are happy to leverage the fact that female developers are being underpaid to... continue to underpay them.
💪 How to push back?
Recruiter:  “And by the way, where are you right now in terms of salary,
and what are your salary expectations if you make this move?”
You: You want to know my current salary?
You: ...
Recruiter: ....
You: Why is it relevant?
Recruiter: That’s part of our standard process, which is as follows…
You: Ah, I see. Thanks for the clarification. Look, I want to be transparent: If you were to make me an offer, it's unlikely I would accept it. Your company isn’t a great fit for me at this time. So I don't want to waste more of your time. But if you wind up brushing up on your interviewing process and making improvements, feel free to reach out to me again for consideration().*
And then: you leave.
(*) line stolen from Erik Dietrich's post on deploying guerilla tactics to combat stupid tech interviews
Does that sound radical to you?
Consider this:
A company has more incentive to be nice to you during the interview process that it will probably never have after. So if that's the way they treat you during the interview, how will they treat you after?
Don't take the risk to work with them.
❓ What about people who don't have a choice?
Some people don't have a choice of rejecting a company, no matter how bad their recruiting process is. What about them?
Well it's precisely because those people don't have a choice that I encourage you to push back against this bad practice if you do have a choice.
Companies try to be consistent in their hiring process, so if candidates who are high in demand start to push back against those practices, the good companies will change their rules, and everyone will benefit.
❓ Isn't that too confrontational?
It's not about being confrontational, it's about polarizing :
I want to spend more time with good companies, and less time with bad companies.
How can you tell at the start of the process that the company is probably not that great?
Well asking for the current salary is a signal as clear as a sign as it can get.
I mean either the question often works or it almost never works.
If it often works, lots of people are working there are underpaid, and that's not a good sign.
If it almost never works, then they are dumb for asking it, and that's not a good sign either.
❓ What if I don't have a choice?
You should still never reveal your current salary.
It's pretty straightforward: you say you are not comfortable sharing your current salary, and you move on.
Still keep in mind that it's a red flag that the company ask you this. If you later have more opportunities, consider changing jobs.
❓ Isn't that common sense?
If it were so, no company would ask this question.
Maybe it's obvious to you who have years of experience in the industry.
But realize that we are in an industry who are is doubling every four or five years.
So there are lots of young inexperienced people who can fall in the trap!
👂 What do recruiters think of this practice?
Obviously, it depends on whether they are good or not-so-good recruiters.
Google What's your current salary? and you will find an insightful article from recruiter Susan P. Joyce:
Asking for your current salary is inappropriate because it is for a different job in a different environment. In addition, this question is illegal for an employer to ask in several locations (listed below).
(....)
If you are feeling brave (or annoyed), you may want to consider going on the offensive and asking them why the salary paid by a different employer is relevant to a company which pays employees fairly. This may end the opportunity quickly, however.
(...)
In a job search, this question is asked by two different people. From an external recruiter, it may be acceptable. From an internal recruiter OR any other employee of the employer, it is not acceptable.
Now, that looks like a recruiter whom you can trust. Thank you, Susan! I encourage you to read the whole thing here
😁 What's next?
I hope that this article was useful!
Next step: let's talk about how you can handle the ssalary expectation question!
Q: What is your salary expectation? A: I don't have one, make me an offer!
Jean-Michel Fayard 🇫🇷🇩🇪🇬🇧🇪🇸🇨🇴 ・ Oct 19 '20 ・ 10 min read
#career
#beginners
#healthydebate
#hiring
",jmfayard/what-is-your-current-salary-is-a-red-flag-that-you-don-t-want-to-work-here-3aji,true,1
2,NextJS 13: 700x Extremely Faster Than Webpack 🚀,"Next.js is an open-source web development framework created by Vercel enabling React-based web applications with server-side rendering and generating static websites.
Recently, Vercel announced the newer version Next.js 13 (stable) on October 25th, 2022 which make it lays the foundations to be dynamic without limits. 🚀
Here are the three major categories that will be discussed thoroughly in this article.
Three major categories of Next.js 13 update:
Compiler Infrastructure
Rendering Infrastructure
Component Toolkit
So, let’s dig deeper into what each announcement entails.
1. Turbopack
Initially, it was obvious to write JavaScript tooling JavaScript, required tools like Babel, Terser, and WebPack. With the growing size and complexity of front-end applications, all these toolings faced bumbling to keep up. For this, the transition was initiated to native rust-powered tooling.
It started by migrating away from Babel, which resulted in 17 times faster transpilation. Terser was next replaced to result in 6 times faster minification.
Similarly, Webpack has become an integral part of building the web that now needed to be reconditioned to build the web’s next-generation bundler.
TurboPack in Next.js 13 shows:
700 times faster updates than Webpack
10 times faster updates than Vite
4 times faster cold starts than Webpack
2. New App Directory
One another important component of Next.js is the file system-based router, which requires no configuration. Having served the feature to the largest web applications in the world it shares new opportunities to enhance it even more.
In the previous versions of next.js, any file created inside the page's directory would act as the route in the UI. The new app directory works adjacent to the page's directory to support incremental adoption and provides other new features like server-side rendering and static-site rendering.
The new app directory supports other attributes like — layouts, server components, streaming, and data fetching.
3. Fresh Font System
The latest version Next.js 13 presents a brand-new font system with amazing properties,
Automatic optimization of fonts including custom fonts
Improved privacy and performance by removal of external network requests
Integral impromptu self-hosting for any font file
Zero layout shift automatically using the CSS size-adjust property
4. New Image Component
A huge portion of the web is made up of images accounting for 44% of a page’s weight on average. Getting the images right is crucial, hence integrating this new image component in Next.js 13 is quite compelling.
The new version put forward substantial improvements to the image component in performance as well as developer experience. For the web platforms available across all major browsers, this new image component set forth,
Native lazy-loading
Better performance
Improved accessibility
Reduced size
Less usage of client-side JavaScripts
Maintains familiar interface
5. Dynamic Social Cards
Also known as open graph images, social cards that has the capability to massively increase the engagement rate of clicks on your web content. The developer community experiences 40% better conversions using dynamic social cards.
Next.js 13 version brings an affordable and contented solution for generating dynamic social cards — OG Image Generation. This outlook is 5 times faster than the existing solution. It utilizes the Vercel edge functions, web assembly, and an advanced new core library for converting HTML and CSS into images and leverages React component abstraction.
6. Middleware API updates
In Next.js 12 there was an addition of new properties that improve the developer’s experience with stable middleware. In Next.js 13, middleware can now modify request headers, and response headers, and send responses.
It allows running code before a request is completed and even can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.
Take a look at how you can set request and response headers using NextResponse API,
Wrap-up
Overall, Next.js 13 enables the use of tooling that prioritizes accessibility and performance which is very important as it allows you to focus on ideation and experimentation within the project. This upgradation will allow people to work seamlessly and efficiently as they want anywhere by building a faster, more performant, and accessible web.
Source —
Next.JS version 13: Latest Features and Upgrade Guide - Ace Infoway
aceinfoway.com
",karanjrawal/nextjs-13-700x-extremely-faster-than-webpack-17a3,false,2
3,What was your win this week?,"Heyo! 👋
Hope y'all all are having a fantastic Friday and that you enjoy your weekends!
Looking back on this past week, what was something you were proud of accomplishing?
All wins count — big or small 🎉
Examples of 'wins' include:
Starting a new project
Fixing a tricky bug
Playing video games until your thumbs are sore! 🎮
",michaeltharrington/what-was-your-win-this-week-2b5e,true,3
4,A look into JSONB in YugabyteDB,"To see how JSON is stored in YugabyteDB, we have to take a look at both PostgreSQL and YugabyteDB.
Let's create two test tables for investigation:
drop table if exists test1;
create table test1 
(
id int primary key,
val json
)
split into 1 tablets
;
drop table if exists test2;
create table test2 
(
id int primary key,
val jsonb
)
split into 1 tablets
;
Enter fullscreen mode
Exit fullscreen mode
The reason I create two tables is to be able to see the difference between PostgreSQL JSON and JSONB. The JSON data type in PostgreSQL is storing JSON as text, while the JSONB is storing JSON binary. The advice from the PostgreSQL documentation is to use JSONB.
With the tables in place, let's create some rows in both:
-- test1 / json
insert into test1 values (1,'{ ""f1"": ""aaaaa"", ""f2"": ""bbbbb"", ""f3"": ""ccccc"", ""f4"": ""ddddd"", ""f5"": ""eeeee"" }');
insert into test1 values (2,'{ ""f1"": ""fffff"", ""f2"": ""ggggg"", ""f3"": ""hhhhh"", ""f4"": ""iiiii"", ""f5"": ""jjjjj"" }');
insert into test1 values (3,'{ ""f1"": ""kkkkk"", ""f2"": ""lllll"", ""f3"": ""mmmmm"", ""f4"": ""nnnnn"", ""f5"": ""ooooo"" }');
-- test2 / jsonb
insert into test2 values (1,'{ ""f1"": ""aaaaa"", ""f2"": ""bbbbb"", ""f3"": ""ccccc"", ""f4"": ""ddddd"", ""f5"": ""eeeee"" }');
insert into test2 values (2,'{ ""f1"": ""fffff"", ""f2"": ""ggggg"", ""f3"": ""hhhhh"", ""f4"": ""iiiii"", ""f5"": ""jjjjj"" }');
insert into test2 values (3,'{ ""f1"": ""kkkkk"", ""f2"": ""lllll"", ""f3"": ""mmmmm"", ""f4"": ""nnnnn"", ""f5"": ""ooooo"" }');
Enter fullscreen mode
Exit fullscreen mode
With the data being inserted in YugabyteDB, let's look at how it's stored in YugabyteDB. In order to do that, access to a tablet server that hosts a replica of the table. 
The reason for the 'split into 1 tablets' clause is to simplify finding the data: if the table would have been split into more tablets, the row will be distributed over the tablets based on the primary key definition. With the default primary key definition the row would have been randomly distributed over the tablets because of hash sharding. With 1 tablet, all the inserted rows will be in the single tablet.
The simplest way to understand where a tablet is hosted in your YugabyteDB cluster is to use an upcoming version of yb_stats to lookup the table specifics:
% yb_stats --print-entities --table-name-match 'test(1|2)'
Table:    ysql.yugabyte.test1, state: RUNNING, id: 000033e8000030008000000000004232
Tablet:   ysql.yugabyte.test1.f1c52b62513f461095b13cb0425b2ef0 state: RUNNING
( VOTER,yb-1.local:9100,FOLLOWER VOTER,yb-3.local:9100,LEADER VOTER,yb-2.local:9100,FOLLOWER )
Table:    ysql.yugabyte.test2, state: RUNNING, id: 000033e8000030008000000000004237
Tablet:   ysql.yugabyte.test2.a535c9ff10fb4fb2b874770ce5cb4ac7 state: RUNNING
( VOTER,yb-1.local:9100,FOLLOWER VOTER,yb-3.local:9100,FOLLOWER VOTER,yb-2.local:9100,LEADER )
Enter fullscreen mode
Exit fullscreen mode
This queries the entities (objects) from the live database, and shows you the two tables test1 and test2 in the yugabyte database, the table id, and the tablet of each of the tables. It also shows the replicas that each tablet has. In the case of a replication factor 3 cluster with 3 nodes, it's obvious that each node gets a replica.
This means we can get to any of the nodes to look at the tablet data for each of the tables: it doesn't matter if a node hosts a follower or leader of a tablet for the two steps that we need to do next.
The first step is to make rocksdb store the table data to an SST file. This might come as a surprise: the data is inserted into YSQL, and committed because of auto commit, yet there is no datafile.
There are two things that are important here: first of all: there is no risk of data-loss, because DocDB provides WAL (write ahead log), which persists any modification to a rocksdb database. The second thing is that LSM-tree provides it's first layer of storage in a memtable, which is, like the name suggests, memory only. 
If the memtable grows beyond the maximum memtable size, then a new memtable is created, and the current memtable is made immutable, sorted and stored to disk as SST file.
In order to read the actual data, we have to ask DocDB to (prematurely) persist the memtable so we can read the rocksdb contents. This is done using a yb-admin command. The above --print-entities command prints the table id (please mind to use the table id, lots of other objects in YugabyteDB have id's too!), which can be used to flush the tablet data to disk:
$ yb-admin -init_master_addrs localhost:7100 flush_table_by_id 000033e8000030008000000000004232 600
Flushed [000033e8000030008000000000004232] tables.
$ yb-admin -init_master_addrs localhost:7100 flush_table_by_id 000033e8000030008000000000004237 600
Flushed [000033e8000030008000000000004237] tables.
Enter fullscreen mode
Exit fullscreen mode
This will generate an .sst file in:
{fs_data_dirs}/yb-data/tserver/data/rocksdb/table-{table id}/tablet-{tablet id}
Enter fullscreen mode
Exit fullscreen mode
If we go to the tablet directory of table1 alias the JSON table, we can then dump the sst file contents in the following way:
$ sst_dump --command=scan --file=. --output_format=decoded_regulardb
from [] to []
Process ./000010.sst
Sst file format: block-based
SubDocKey(DocKey(0x1210, [1], []), [SystemColumnId(0); HT{ physical: 1669383197054696 }]) -&gt; null
SubDocKey(DocKey(0x1210, [1], []), [ColumnId(1); HT{ physical: 1669383197054696 w: 1 }]) -&gt; ""\x9d{ \""f1\"": \""aaaaa\"", \""f2\"": \""bbbbb\"", \""f3\"": \""ccccc\"", \""f4\"": \""ddddd\"", \""f5\"": \""eeeee\"" }""
SubDocKey(DocKey(0xc0c4, [2], []), [SystemColumnId(0); HT{ physical: 1669383197061929 }]) -&gt; null
SubDocKey(DocKey(0xc0c4, [2], []), [ColumnId(1); HT{ physical: 1669383197061929 w: 1 }]) -&gt; ""\x9d{ \""f1\"": \""fffff\"", \""f2\"": \""ggggg\"", \""f3\"": \""hhhhh\"", \""f4\"": \""iiiii\"", \""f5\"": \""jjjjj\"" }""
SubDocKey(DocKey(0xfca0, [3], []), [SystemColumnId(0); HT{ physical: 1669383197066513 }]) -&gt; null
SubDocKey(DocKey(0xfca0, [3], []), [ColumnId(1); HT{ physical: 1669383197066513 w: 1 }]) -&gt; ""\x9d{ \""f1\"": \""kkkkk\"", \""f2\"": \""lllll\"", \""f3\"": \""mmmmm\"", \""f4\"": \""nnnnn\"", \""f5\"": \""ooooo\"" }""
Enter fullscreen mode
Exit fullscreen mode
Now let's take a look at the output. 
All the SubDocKeys contain a DocKey. The DocKey stores the primary key. The first column in the DocKey is a hash value of the row, the second column is the actual primary key value.
The first row in the output above is the SystemColumnId, which is invisible at the user layer, and is commonly referred to as 'liveness column'. This column is used to indicate the row presence.
The row after the SystemColumnId row is the second column in the table. If you inspect the row data after '-&gt;', you see that the actual JSON text is visible. In other words: despite being a JSON column, the JSON textual representation is stored at the DocDB layer, and is what is provided to YSQL if the column is requested.
In all rows alias SubDocKeys you find data with 'HT': the Hybrid (Logical Clock) Time. This is how MVCC is implemented.
Now let's go to the test2 table data, and use the sst_dump tool to see how the JSONB data looks like:
$ sst_dump --command=scan --file=. --output_format=decoded_regulardb
from [] to []
Process ./000010.sst
Sst file format: block-based
SubDocKey(DocKey(0x1210, [1], []), [SystemColumnId(0); HT{ physical: 1669383197078672 }]) -&gt; null
SubDocKey(DocKey(0x1210, [1], []), [ColumnId(1); HT{ physical: 1669383197078672 w: 1 }]) -&gt; ""\x05\x00\x00 \x02\x00\x00\x80\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00f1f2f3f4f5aaaaabbbbbcccccdddddeeeee""
SubDocKey(DocKey(0xc0c4, [2], []), [SystemColumnId(0); HT{ physical: 1669383197086482 }]) -&gt; null
SubDocKey(DocKey(0xc0c4, [2], []), [ColumnId(1); HT{ physical: 1669383197086482 w: 1 }]) -&gt; ""\x05\x00\x00 \x02\x00\x00\x80\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00f1f2f3f4f5fffffggggghhhhhiiiiijjjjj""
SubDocKey(DocKey(0xfca0, [3], []), [SystemColumnId(0); HT{ physical: 1669383198094809 }]) -&gt; null
SubDocKey(DocKey(0xfca0, [3], []), [ColumnId(1); HT{ physical: 1669383198094809 w: 1 }]) -&gt; ""\x05\x00\x00 \x02\x00\x00\x80\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00\x05\x00\x00\x00f1f2f3f4f5kkkkklllllmmmmmnnnnnooooo""
Enter fullscreen mode
Exit fullscreen mode
The layout of the sst data is identical: the primary key sits in the DocKey, we got a 'liveness column' per row, and the JSONB column is singular. The data in the JSONB column differs from the JSON column: the JSON data is stored in a binary way so it can be used directly by YSQL.
",yugabyte/a-look-into-jsonb-in-yugabytedb-59n2,false,4
5,5 major UX design mistakes to avoid before users uninstall your app 😲,"Most apps lose 80% of new users within the first 90 days.
More than half of all users who uninstall your app will do so within the first four to five days — the typical onboarding period.
Poor UX is the top reason why users abandon your app.
Your mobile app navigation should avoid these 5 major UX design mistakes.🚀
Mobile app navigation: 5 major UX design mistakes 😟
5/5 — Your navigation menu has too many options
The primary mobile navigation menu of the app can be accessed via the navigation menu. Therefore, if the opportunities in the primary navigation menu are too many, users can get confused and quit the app without taking any action.
Take an example of a restaurant menu, if you have so many dish options you get confused &amp; overwhelmed and it is often hard to decide on the best dish. It’s the same with apps. Users will leave an app if it has an extensive list of items they find difficult to quickly comprehend.
Practical recommendation:
It is better to keep the primary navigation menu precise and short. So, users can quickly scan the entire menu without taking too much time. The clearer your UX navigation for the menu is to the users, the better the designers have done the job.
4/5 — Hidden navigation menu
Hidden navigation menu like a hamburger menu has hoover through navigation components in an app like a hurricane. No trend, though, is without its critics.
Out of sight, out of mind is the fundamental root of the problem with hidden menus. Users are less likely to tap on a menu when they can’t see it. Using a hidden navigation menu to discover what you want requires more cognitive work.
Users don’t use their mobile phones in a perfectly focused way, like a usability test. They often have several things on their minds at once, so if your navigation isn’t visible, then it might drive potential users away.
Practical recommendation:
Hamburger menus or hidden navigation menus are great for all secondary navigation menus. Therefore, the common advice is to use visible navigation, where the primary navigation choices are shown in a visible navigation bar, or combination navigation, where some of the primary navigation options are visible and others are concealed under an interactive element.
3/5 — Using the wrong colors
Around 300 million individuals worldwide are believed to have a color vision deficiency. 1 in 12 men and 1 in 200 women are color blind. Therefore, most designers don’t face color blindness issues, so it’s easy to forget that we’re developing for this specific user group too.
While using light fonts on light backgrounds in the mobile navigation menu may look elegant but in this type of color contrast, the content/menu is unreadable. Additionally, using light fonts in small body text may cause usability issues. Users are likely to uninstall your app if it has a visually appealing UI but is challenging to understand.
Practical recommendation:
For a great user experience, app designers and developers must create fonts readable and provide excellent contrast between text and background. In addition, you will be much closer to professionally selecting colors and designing an appealing app if you use tools like Coolors, Palette, etc. to assist you in building color combinations rather than picking colors at random.
2/5 — Avoid using jargon that users don’t understand
Jargon when used in mobile apps to impress customers will have a negative impact if not understood by the customers. Speak in the same language as your customers. Unfamiliar words or phrases will increase the cognitive load of the user. Professional jargon and brand message should never take precedence over clear communication and functionality.
Practical recommendation:
Avoid using jargon when explaining non-specialized subjects. Additionally, avoid using jargon just because you think it sounds sophisticated. (Really, you’re more likely to come across as arrogant if you use jargon needlessly.)
It might be challenging to avoid jargon. So, we’d suggest following a few basic guidelines when using jargon in an app:
Know your audience
Determine each user’s tech knowledge
Provide context
1/5 — Cluttering up the user interface
A cluttered user interface overwhelms the user with too much information; each additional button, image, and line of text complicates the screen. On a desktop, clutter is awful, but on mobile devices, where users have little screen real estate, clutter is even worse.
Even if all of your content is relevant and engaging, cluttering your app with too much information will simply turn visitors away.
Practical recommendation:
If you have a lot of information to display, use progressive disclosure, if possible. In other words, additional alternatives are shown as the user clicks or hovers over the interface. Content should only be visible when the user requests to view it.
Concentrate on the content or information that is helpful to your users. Remove unnecessary elements that do not assist user tasks. Keep the interface light and airy by using a few aesthetic elements, such as gradients and drop shadows.
Wrap-up
The process of app navigation design is long and requires lots of effort. In the future or while designing an app, try to stay away from these common mistakes since they often need design changes, which increases your post-design efforts.
Designers need to be up-to-date on user behavior trends and customer psychology. The most crucial consideration when building an app is to consider the user’s point of view. Never choose or reject a color, font, or design based only on personal preference. Instead, do your research and follow the trend.
Source: https://bit.ly/3TXOaWW
For more information, keep reading here. 
",karanjrawal/5-major-ux-design-mistakes-to-avoid-before-users-uninstall-your-app-4mak,false,2
